/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import { Listener, Provider } from "@ethersproject/providers";
import { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from "./common";

export declare namespace OrderMixin {
  export type OrderStruct = {
    salt: BigNumberish;
    asset: string;
    underlyingAsset: string;
    maker: string;
    receiver: string;
    allowedSender: string;
    fixedTokens: BigNumberish;
    variableTokens: BigNumberish;
    isFixedTaker: boolean;
    beginTimestamp: BigNumberish;
    endTimestamp: BigNumberish;
    t: BigNumberish;
    makerAssetData: BytesLike;
    takerAssetData: BytesLike;
    getMakerAmount: BytesLike;
    getTakerAmount: BytesLike;
    predicate: BytesLike;
    permit: BytesLike;
    interaction: BytesLike;
  };

  export type OrderStructOutput = [
    BigNumber,
    string,
    string,
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    boolean,
    BigNumber,
    BigNumber,
    BigNumber,
    string,
    string,
    string,
    string,
    string,
    string,
    string
  ] & {
    salt: BigNumber;
    asset: string;
    underlyingAsset: string;
    maker: string;
    receiver: string;
    allowedSender: string;
    fixedTokens: BigNumber;
    variableTokens: BigNumber;
    isFixedTaker: boolean;
    beginTimestamp: BigNumber;
    endTimestamp: BigNumber;
    t: BigNumber;
    makerAssetData: string;
    takerAssetData: string;
    getMakerAmount: string;
    getTakerAmount: string;
    predicate: string;
    permit: string;
    interaction: string;
  };
}

export interface OrderMixinInterface extends utils.Interface {
  contractName: "OrderMixin";
  functions: {
    "LIMIT_ORDER_TYPEHASH()": FunctionFragment;
    "addMargin((uint256,address,address,address,address,address,uint256,uint256,bool,uint256,uint256,int128,bytes,bytes,bytes,bytes,bytes,bytes,bytes),address,uint256)": FunctionFragment;
    "advanceNonce(uint8)": FunctionFragment;
    "and(address[],bytes[])": FunctionFragment;
    "arbitraryStaticCall(address,bytes)": FunctionFragment;
    "assetAlpha(address)": FunctionFragment;
    "assetBeta(address)": FunctionFragment;
    "assetLowerBoundMul(address)": FunctionFragment;
    "assetSigma(address)": FunctionFragment;
    "assetUpperBoundMul(address)": FunctionFragment;
    "cancelOrder((uint256,address,address,address,address,address,uint256,uint256,bool,uint256,uint256,int128,bytes,bytes,bytes,bytes,bytes,bytes,bytes))": FunctionFragment;
    "checkPredicate((uint256,address,address,address,address,address,uint256,uint256,bool,uint256,uint256,int128,bytes,bytes,bytes,bytes,bytes,bytes,bytes))": FunctionFragment;
    "defaultedFunds(bytes32)": FunctionFragment;
    "doublePrice(address,address,uint256,int256,uint256)": FunctionFragment;
    "eq(uint256,address,bytes)": FunctionFragment;
    "fillOrder((uint256,address,address,address,address,address,uint256,uint256,bool,uint256,uint256,int128,bytes,bytes,bytes,bytes,bytes,bytes,bytes),bytes,uint256,uint256,uint256)": FunctionFragment;
    "fillOrderTo((uint256,address,address,address,address,address,uint256,uint256,bool,uint256,uint256,int128,bytes,bytes,bytes,bytes,bytes,bytes,bytes),bytes,uint256,uint256,uint256)": FunctionFragment;
    "fillOrderToWithPermit((uint256,address,address,address,address,address,uint256,uint256,bool,uint256,uint256,int128,bytes,bytes,bytes,bytes,bytes,bytes,bytes),bytes,uint256,uint256,uint256,bytes)": FunctionFragment;
    "getAverageAccruedAPYBetweenTimestamps(address,address,uint256,uint256)": FunctionFragment;
    "getInitialMarginReq((uint256,address,address,address,address,address,uint256,uint256,bool,uint256,uint256,int128,bytes,bytes,bytes,bytes,bytes,bytes,bytes),bytes32,address)": FunctionFragment;
    "getMakerAmount(uint256,uint256,uint256)": FunctionFragment;
    "getMarginReq((uint256,address,address,address,address,address,uint256,uint256,bool,uint256,uint256,int128,bytes,bytes,bytes,bytes,bytes,bytes,bytes),bytes32,address)": FunctionFragment;
    "getTakerAmount(uint256,uint256,uint256)": FunctionFragment;
    "gt(uint256,address,bytes)": FunctionFragment;
    "hashOrder((uint256,address,address,address,address,address,uint256,uint256,bool,uint256,uint256,int128,bytes,bytes,bytes,bytes,bytes,bytes,bytes))": FunctionFragment;
    "increaseNonce()": FunctionFragment;
    "isOrderDefaulted(bytes32)": FunctionFragment;
    "liquidate((uint256,address,address,address,address,address,uint256,uint256,bool,uint256,uint256,int128,bytes,bytes,bytes,bytes,bytes,bytes,bytes),address)": FunctionFragment;
    "liquidatorMargin()": FunctionFragment;
    "lt(uint256,address,bytes)": FunctionFragment;
    "nonce(address)": FunctionFragment;
    "nonceEquals(address,uint256)": FunctionFragment;
    "oppositePartyMargin()": FunctionFragment;
    "oppositePartyMarginNoLiquidator()": FunctionFragment;
    "or(address[],bytes[])": FunctionFragment;
    "orderParticipantFixedTokens(bytes32,address)": FunctionFragment;
    "orderParticipantMargin(bytes32,address)": FunctionFragment;
    "orderParticipantVariableTokens(bytes32,address)": FunctionFragment;
    "owner()": FunctionFragment;
    "remaining(bytes32)": FunctionFragment;
    "remainingRaw(bytes32)": FunctionFragment;
    "setAssetAlpha(address,int128)": FunctionFragment;
    "setAssetBeta(address,int128)": FunctionFragment;
    "setAssetLowerBoundMul(address,int128)": FunctionFragment;
    "setAssetSigma(address,int128)": FunctionFragment;
    "setAssetUpperBoundMul(address,int128)": FunctionFragment;
    "setLiquidatorMargin(int128)": FunctionFragment;
    "setOppositePartyMargin(int128)": FunctionFragment;
    "setOppositePartyMarginNoLiquidator(int128)": FunctionFragment;
    "settleOrder((uint256,address,address,address,address,address,uint256,uint256,bool,uint256,uint256,int128,bytes,bytes,bytes,bytes,bytes,bytes,bytes),address)": FunctionFragment;
    "simulateCalls(address[],bytes[])": FunctionFragment;
    "singlePrice(address,uint256,uint256)": FunctionFragment;
    "timestampBelow(uint256)": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "LIMIT_ORDER_TYPEHASH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "addMargin",
    values: [OrderMixin.OrderStruct, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "advanceNonce",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "and",
    values: [string[], BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "arbitraryStaticCall",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "assetAlpha", values: [string]): string;
  encodeFunctionData(functionFragment: "assetBeta", values: [string]): string;
  encodeFunctionData(
    functionFragment: "assetLowerBoundMul",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "assetSigma", values: [string]): string;
  encodeFunctionData(
    functionFragment: "assetUpperBoundMul",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelOrder",
    values: [OrderMixin.OrderStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "checkPredicate",
    values: [OrderMixin.OrderStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "defaultedFunds",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "doublePrice",
    values: [string, string, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "eq",
    values: [BigNumberish, string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "fillOrder",
    values: [
      OrderMixin.OrderStruct,
      BytesLike,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fillOrderTo",
    values: [
      OrderMixin.OrderStruct,
      BytesLike,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fillOrderToWithPermit",
    values: [
      OrderMixin.OrderStruct,
      BytesLike,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getAverageAccruedAPYBetweenTimestamps",
    values: [string, string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getInitialMarginReq",
    values: [OrderMixin.OrderStruct, BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "getMakerAmount",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getMarginReq",
    values: [OrderMixin.OrderStruct, BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "getTakerAmount",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "gt",
    values: [BigNumberish, string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "hashOrder",
    values: [OrderMixin.OrderStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "increaseNonce",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "isOrderDefaulted",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "liquidate",
    values: [OrderMixin.OrderStruct, string]
  ): string;
  encodeFunctionData(
    functionFragment: "liquidatorMargin",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "lt",
    values: [BigNumberish, string, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "nonce", values: [string]): string;
  encodeFunctionData(
    functionFragment: "nonceEquals",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "oppositePartyMargin",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "oppositePartyMarginNoLiquidator",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "or",
    values: [string[], BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "orderParticipantFixedTokens",
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "orderParticipantMargin",
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "orderParticipantVariableTokens",
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "remaining",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "remainingRaw",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setAssetAlpha",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setAssetBeta",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setAssetLowerBoundMul",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setAssetSigma",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setAssetUpperBoundMul",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setLiquidatorMargin",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setOppositePartyMargin",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setOppositePartyMarginNoLiquidator",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "settleOrder",
    values: [OrderMixin.OrderStruct, string]
  ): string;
  encodeFunctionData(
    functionFragment: "simulateCalls",
    values: [string[], BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "singlePrice",
    values: [string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "timestampBelow",
    values: [BigNumberish]
  ): string;

  decodeFunctionResult(
    functionFragment: "LIMIT_ORDER_TYPEHASH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "addMargin", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "advanceNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "and", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "arbitraryStaticCall",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "assetAlpha", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "assetBeta", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "assetLowerBoundMul",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "assetSigma", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "assetUpperBoundMul",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "checkPredicate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "defaultedFunds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "doublePrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "eq", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fillOrder", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "fillOrderTo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fillOrderToWithPermit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAverageAccruedAPYBetweenTimestamps",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getInitialMarginReq",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMakerAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMarginReq",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTakerAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "gt", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "hashOrder", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "increaseNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isOrderDefaulted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "liquidate", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "liquidatorMargin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "lt", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "nonce", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "nonceEquals",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "oppositePartyMargin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "oppositePartyMarginNoLiquidator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "or", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "orderParticipantFixedTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "orderParticipantMargin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "orderParticipantVariableTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "remaining", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "remainingRaw",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setAssetAlpha",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setAssetBeta",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setAssetLowerBoundMul",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setAssetSigma",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setAssetUpperBoundMul",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setLiquidatorMargin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setOppositePartyMargin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setOppositePartyMarginNoLiquidator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "settleOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "simulateCalls",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "singlePrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "timestampBelow",
    data: BytesLike
  ): Result;

  events: {
    "NonceIncreased(address,uint256)": EventFragment;
    "OrderCanceled(address,bytes32,uint256)": EventFragment;
    "OrderFilled(address,bytes32,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "NonceIncreased"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OrderCanceled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OrderFilled"): EventFragment;
}

export type NonceIncreasedEvent = TypedEvent<
  [string, BigNumber],
  { maker: string; newNonce: BigNumber }
>;

export type NonceIncreasedEventFilter = TypedEventFilter<NonceIncreasedEvent>;

export type OrderCanceledEvent = TypedEvent<
  [string, string, BigNumber],
  { maker: string; orderHash: string; remainingRaw: BigNumber }
>;

export type OrderCanceledEventFilter = TypedEventFilter<OrderCanceledEvent>;

export type OrderFilledEvent = TypedEvent<
  [string, string, BigNumber],
  { maker: string; orderHash: string; remaining: BigNumber }
>;

export type OrderFilledEventFilter = TypedEventFilter<OrderFilledEvent>;

export interface OrderMixin extends BaseContract {
  contractName: "OrderMixin";
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: OrderMixinInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    LIMIT_ORDER_TYPEHASH(overrides?: CallOverrides): Promise<[string]>;

    addMargin(
      order: OrderMixin.OrderStruct,
      participant: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    advanceNonce(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    and(
      targets: string[],
      data: BytesLike[],
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    arbitraryStaticCall(
      target: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    assetAlpha(arg0: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    assetBeta(arg0: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    assetLowerBoundMul(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    assetSigma(arg0: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    assetUpperBoundMul(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    cancelOrder(
      order: OrderMixin.OrderStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    checkPredicate(
      order: OrderMixin.OrderStruct,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    defaultedFunds(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    doublePrice(
      oracle1: string,
      oracle2: string,
      spread: BigNumberish,
      decimalsScale: BigNumberish,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    eq(
      value: BigNumberish,
      target: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    fillOrder(
      order: OrderMixin.OrderStruct,
      signature: BytesLike,
      fixedTokens: BigNumberish,
      variableTokens: BigNumberish,
      thresholdTokens: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fillOrderTo(
      order: OrderMixin.OrderStruct,
      signature: BytesLike,
      fixedTokens: BigNumberish,
      variableTokens: BigNumberish,
      thresholdTokens: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fillOrderToWithPermit(
      order: OrderMixin.OrderStruct,
      signature: BytesLike,
      fixedTokens: BigNumberish,
      variableTokens: BigNumberish,
      thresholdTokens: BigNumberish,
      permit: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    getAverageAccruedAPYBetweenTimestamps(
      asset: string,
      underlyingAsset: string,
      startTimestamp: BigNumberish,
      endTimestamp: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber] & { apy: BigNumber; ewma: BigNumber }>;

    getInitialMarginReq(
      order: OrderMixin.OrderStruct,
      orderHash: BytesLike,
      participant: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getMakerAmount(
      orderMakerAmount: BigNumberish,
      orderTakerAmount: BigNumberish,
      swapTakerAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getMarginReq(
      order: OrderMixin.OrderStruct,
      orderHash: BytesLike,
      participant: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getTakerAmount(
      orderMakerAmount: BigNumberish,
      orderTakerAmount: BigNumberish,
      swapMakerAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    gt(
      value: BigNumberish,
      target: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    hashOrder(
      order: OrderMixin.OrderStruct,
      overrides?: CallOverrides
    ): Promise<[string]>;

    increaseNonce(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    isOrderDefaulted(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    liquidate(
      order: OrderMixin.OrderStruct,
      defaulter: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    liquidatorMargin(overrides?: CallOverrides): Promise<[BigNumber]>;

    lt(
      value: BigNumberish,
      target: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    nonce(arg0: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    nonceEquals(
      makerAddress: string,
      makerNonce: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    oppositePartyMargin(overrides?: CallOverrides): Promise<[BigNumber]>;

    oppositePartyMarginNoLiquidator(
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    or(
      targets: string[],
      data: BytesLike[],
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    orderParticipantFixedTokens(
      arg0: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    orderParticipantMargin(
      arg0: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    orderParticipantVariableTokens(
      arg0: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    remaining(
      orderHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    remainingRaw(
      orderHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    setAssetAlpha(
      asset: string,
      alpha: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setAssetBeta(
      asset: string,
      beta: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setAssetLowerBoundMul(
      asset: string,
      lowerBoundMul: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setAssetSigma(
      asset: string,
      sigma: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setAssetUpperBoundMul(
      asset: string,
      upperBoundMul: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setLiquidatorMargin(
      _liquidatorMargin: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setOppositePartyMargin(
      _oppositePartyMargin: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setOppositePartyMarginNoLiquidator(
      _oppositePartyMarginNoLiquidator: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    settleOrder(
      order: OrderMixin.OrderStruct,
      settler: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    simulateCalls(
      targets: string[],
      data: BytesLike[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    singlePrice(
      oracle: string,
      inverseAndSpread: BigNumberish,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    timestampBelow(
      time: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean]>;
  };

  LIMIT_ORDER_TYPEHASH(overrides?: CallOverrides): Promise<string>;

  addMargin(
    order: OrderMixin.OrderStruct,
    participant: string,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  advanceNonce(
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  and(
    targets: string[],
    data: BytesLike[],
    overrides?: CallOverrides
  ): Promise<boolean>;

  arbitraryStaticCall(
    target: string,
    data: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  assetAlpha(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

  assetBeta(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

  assetLowerBoundMul(
    arg0: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  assetSigma(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

  assetUpperBoundMul(
    arg0: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  cancelOrder(
    order: OrderMixin.OrderStruct,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  checkPredicate(
    order: OrderMixin.OrderStruct,
    overrides?: CallOverrides
  ): Promise<boolean>;

  defaultedFunds(
    arg0: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  doublePrice(
    oracle1: string,
    oracle2: string,
    spread: BigNumberish,
    decimalsScale: BigNumberish,
    amount: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  eq(
    value: BigNumberish,
    target: string,
    data: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  fillOrder(
    order: OrderMixin.OrderStruct,
    signature: BytesLike,
    fixedTokens: BigNumberish,
    variableTokens: BigNumberish,
    thresholdTokens: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fillOrderTo(
    order: OrderMixin.OrderStruct,
    signature: BytesLike,
    fixedTokens: BigNumberish,
    variableTokens: BigNumberish,
    thresholdTokens: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fillOrderToWithPermit(
    order: OrderMixin.OrderStruct,
    signature: BytesLike,
    fixedTokens: BigNumberish,
    variableTokens: BigNumberish,
    thresholdTokens: BigNumberish,
    permit: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  getAverageAccruedAPYBetweenTimestamps(
    asset: string,
    underlyingAsset: string,
    startTimestamp: BigNumberish,
    endTimestamp: BigNumberish,
    overrides?: CallOverrides
  ): Promise<[BigNumber, BigNumber] & { apy: BigNumber; ewma: BigNumber }>;

  getInitialMarginReq(
    order: OrderMixin.OrderStruct,
    orderHash: BytesLike,
    participant: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getMakerAmount(
    orderMakerAmount: BigNumberish,
    orderTakerAmount: BigNumberish,
    swapTakerAmount: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getMarginReq(
    order: OrderMixin.OrderStruct,
    orderHash: BytesLike,
    participant: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getTakerAmount(
    orderMakerAmount: BigNumberish,
    orderTakerAmount: BigNumberish,
    swapMakerAmount: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  gt(
    value: BigNumberish,
    target: string,
    data: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  hashOrder(
    order: OrderMixin.OrderStruct,
    overrides?: CallOverrides
  ): Promise<string>;

  increaseNonce(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  isOrderDefaulted(
    arg0: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  liquidate(
    order: OrderMixin.OrderStruct,
    defaulter: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  liquidatorMargin(overrides?: CallOverrides): Promise<BigNumber>;

  lt(
    value: BigNumberish,
    target: string,
    data: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  nonce(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

  nonceEquals(
    makerAddress: string,
    makerNonce: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  oppositePartyMargin(overrides?: CallOverrides): Promise<BigNumber>;

  oppositePartyMarginNoLiquidator(
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  or(
    targets: string[],
    data: BytesLike[],
    overrides?: CallOverrides
  ): Promise<boolean>;

  orderParticipantFixedTokens(
    arg0: BytesLike,
    arg1: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  orderParticipantMargin(
    arg0: BytesLike,
    arg1: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  orderParticipantVariableTokens(
    arg0: BytesLike,
    arg1: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  owner(overrides?: CallOverrides): Promise<string>;

  remaining(
    orderHash: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  remainingRaw(
    orderHash: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  setAssetAlpha(
    asset: string,
    alpha: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setAssetBeta(
    asset: string,
    beta: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setAssetLowerBoundMul(
    asset: string,
    lowerBoundMul: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setAssetSigma(
    asset: string,
    sigma: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setAssetUpperBoundMul(
    asset: string,
    upperBoundMul: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setLiquidatorMargin(
    _liquidatorMargin: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setOppositePartyMargin(
    _oppositePartyMargin: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setOppositePartyMarginNoLiquidator(
    _oppositePartyMarginNoLiquidator: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  settleOrder(
    order: OrderMixin.OrderStruct,
    settler: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  simulateCalls(
    targets: string[],
    data: BytesLike[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  singlePrice(
    oracle: string,
    inverseAndSpread: BigNumberish,
    amount: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  timestampBelow(
    time: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  callStatic: {
    LIMIT_ORDER_TYPEHASH(overrides?: CallOverrides): Promise<string>;

    addMargin(
      order: OrderMixin.OrderStruct,
      participant: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    advanceNonce(
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    and(
      targets: string[],
      data: BytesLike[],
      overrides?: CallOverrides
    ): Promise<boolean>;

    arbitraryStaticCall(
      target: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    assetAlpha(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    assetBeta(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    assetLowerBoundMul(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    assetSigma(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    assetUpperBoundMul(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    cancelOrder(
      order: OrderMixin.OrderStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    checkPredicate(
      order: OrderMixin.OrderStruct,
      overrides?: CallOverrides
    ): Promise<boolean>;

    defaultedFunds(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    doublePrice(
      oracle1: string,
      oracle2: string,
      spread: BigNumberish,
      decimalsScale: BigNumberish,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    eq(
      value: BigNumberish,
      target: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    fillOrder(
      order: OrderMixin.OrderStruct,
      signature: BytesLike,
      fixedTokens: BigNumberish,
      variableTokens: BigNumberish,
      thresholdTokens: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    fillOrderTo(
      order: OrderMixin.OrderStruct,
      signature: BytesLike,
      fixedTokens: BigNumberish,
      variableTokens: BigNumberish,
      thresholdTokens: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    fillOrderToWithPermit(
      order: OrderMixin.OrderStruct,
      signature: BytesLike,
      fixedTokens: BigNumberish,
      variableTokens: BigNumberish,
      thresholdTokens: BigNumberish,
      permit: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    getAverageAccruedAPYBetweenTimestamps(
      asset: string,
      underlyingAsset: string,
      startTimestamp: BigNumberish,
      endTimestamp: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber] & { apy: BigNumber; ewma: BigNumber }>;

    getInitialMarginReq(
      order: OrderMixin.OrderStruct,
      orderHash: BytesLike,
      participant: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getMakerAmount(
      orderMakerAmount: BigNumberish,
      orderTakerAmount: BigNumberish,
      swapTakerAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getMarginReq(
      order: OrderMixin.OrderStruct,
      orderHash: BytesLike,
      participant: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTakerAmount(
      orderMakerAmount: BigNumberish,
      orderTakerAmount: BigNumberish,
      swapMakerAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    gt(
      value: BigNumberish,
      target: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    hashOrder(
      order: OrderMixin.OrderStruct,
      overrides?: CallOverrides
    ): Promise<string>;

    increaseNonce(overrides?: CallOverrides): Promise<void>;

    isOrderDefaulted(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    liquidate(
      order: OrderMixin.OrderStruct,
      defaulter: string,
      overrides?: CallOverrides
    ): Promise<void>;

    liquidatorMargin(overrides?: CallOverrides): Promise<BigNumber>;

    lt(
      value: BigNumberish,
      target: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    nonce(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    nonceEquals(
      makerAddress: string,
      makerNonce: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    oppositePartyMargin(overrides?: CallOverrides): Promise<BigNumber>;

    oppositePartyMarginNoLiquidator(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    or(
      targets: string[],
      data: BytesLike[],
      overrides?: CallOverrides
    ): Promise<boolean>;

    orderParticipantFixedTokens(
      arg0: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    orderParticipantMargin(
      arg0: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    orderParticipantVariableTokens(
      arg0: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<string>;

    remaining(
      orderHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    remainingRaw(
      orderHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setAssetAlpha(
      asset: string,
      alpha: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    setAssetBeta(
      asset: string,
      beta: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    setAssetLowerBoundMul(
      asset: string,
      lowerBoundMul: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    setAssetSigma(
      asset: string,
      sigma: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    setAssetUpperBoundMul(
      asset: string,
      upperBoundMul: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    setLiquidatorMargin(
      _liquidatorMargin: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    setOppositePartyMargin(
      _oppositePartyMargin: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    setOppositePartyMarginNoLiquidator(
      _oppositePartyMarginNoLiquidator: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    settleOrder(
      order: OrderMixin.OrderStruct,
      settler: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    simulateCalls(
      targets: string[],
      data: BytesLike[],
      overrides?: CallOverrides
    ): Promise<void>;

    singlePrice(
      oracle: string,
      inverseAndSpread: BigNumberish,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    timestampBelow(
      time: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;
  };

  filters: {
    "NonceIncreased(address,uint256)"(
      maker?: string | null,
      newNonce?: null
    ): NonceIncreasedEventFilter;
    NonceIncreased(
      maker?: string | null,
      newNonce?: null
    ): NonceIncreasedEventFilter;

    "OrderCanceled(address,bytes32,uint256)"(
      maker?: string | null,
      orderHash?: null,
      remainingRaw?: null
    ): OrderCanceledEventFilter;
    OrderCanceled(
      maker?: string | null,
      orderHash?: null,
      remainingRaw?: null
    ): OrderCanceledEventFilter;

    "OrderFilled(address,bytes32,uint256)"(
      maker?: string | null,
      orderHash?: null,
      remaining?: null
    ): OrderFilledEventFilter;
    OrderFilled(
      maker?: string | null,
      orderHash?: null,
      remaining?: null
    ): OrderFilledEventFilter;
  };

  estimateGas: {
    LIMIT_ORDER_TYPEHASH(overrides?: CallOverrides): Promise<BigNumber>;

    addMargin(
      order: OrderMixin.OrderStruct,
      participant: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    advanceNonce(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    and(
      targets: string[],
      data: BytesLike[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    arbitraryStaticCall(
      target: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    assetAlpha(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    assetBeta(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    assetLowerBoundMul(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    assetSigma(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    assetUpperBoundMul(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    cancelOrder(
      order: OrderMixin.OrderStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    checkPredicate(
      order: OrderMixin.OrderStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    defaultedFunds(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    doublePrice(
      oracle1: string,
      oracle2: string,
      spread: BigNumberish,
      decimalsScale: BigNumberish,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    eq(
      value: BigNumberish,
      target: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fillOrder(
      order: OrderMixin.OrderStruct,
      signature: BytesLike,
      fixedTokens: BigNumberish,
      variableTokens: BigNumberish,
      thresholdTokens: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fillOrderTo(
      order: OrderMixin.OrderStruct,
      signature: BytesLike,
      fixedTokens: BigNumberish,
      variableTokens: BigNumberish,
      thresholdTokens: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fillOrderToWithPermit(
      order: OrderMixin.OrderStruct,
      signature: BytesLike,
      fixedTokens: BigNumberish,
      variableTokens: BigNumberish,
      thresholdTokens: BigNumberish,
      permit: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    getAverageAccruedAPYBetweenTimestamps(
      asset: string,
      underlyingAsset: string,
      startTimestamp: BigNumberish,
      endTimestamp: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getInitialMarginReq(
      order: OrderMixin.OrderStruct,
      orderHash: BytesLike,
      participant: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getMakerAmount(
      orderMakerAmount: BigNumberish,
      orderTakerAmount: BigNumberish,
      swapTakerAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getMarginReq(
      order: OrderMixin.OrderStruct,
      orderHash: BytesLike,
      participant: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTakerAmount(
      orderMakerAmount: BigNumberish,
      orderTakerAmount: BigNumberish,
      swapMakerAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    gt(
      value: BigNumberish,
      target: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hashOrder(
      order: OrderMixin.OrderStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    increaseNonce(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    isOrderDefaulted(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    liquidate(
      order: OrderMixin.OrderStruct,
      defaulter: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    liquidatorMargin(overrides?: CallOverrides): Promise<BigNumber>;

    lt(
      value: BigNumberish,
      target: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    nonce(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    nonceEquals(
      makerAddress: string,
      makerNonce: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    oppositePartyMargin(overrides?: CallOverrides): Promise<BigNumber>;

    oppositePartyMarginNoLiquidator(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    or(
      targets: string[],
      data: BytesLike[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    orderParticipantFixedTokens(
      arg0: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    orderParticipantMargin(
      arg0: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    orderParticipantVariableTokens(
      arg0: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    remaining(
      orderHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    remainingRaw(
      orderHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setAssetAlpha(
      asset: string,
      alpha: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setAssetBeta(
      asset: string,
      beta: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setAssetLowerBoundMul(
      asset: string,
      lowerBoundMul: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setAssetSigma(
      asset: string,
      sigma: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setAssetUpperBoundMul(
      asset: string,
      upperBoundMul: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setLiquidatorMargin(
      _liquidatorMargin: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setOppositePartyMargin(
      _oppositePartyMargin: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setOppositePartyMarginNoLiquidator(
      _oppositePartyMarginNoLiquidator: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    settleOrder(
      order: OrderMixin.OrderStruct,
      settler: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    simulateCalls(
      targets: string[],
      data: BytesLike[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    singlePrice(
      oracle: string,
      inverseAndSpread: BigNumberish,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    timestampBelow(
      time: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    LIMIT_ORDER_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    addMargin(
      order: OrderMixin.OrderStruct,
      participant: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    advanceNonce(
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    and(
      targets: string[],
      data: BytesLike[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    arbitraryStaticCall(
      target: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    assetAlpha(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    assetBeta(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    assetLowerBoundMul(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    assetSigma(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    assetUpperBoundMul(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    cancelOrder(
      order: OrderMixin.OrderStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    checkPredicate(
      order: OrderMixin.OrderStruct,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    defaultedFunds(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    doublePrice(
      oracle1: string,
      oracle2: string,
      spread: BigNumberish,
      decimalsScale: BigNumberish,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    eq(
      value: BigNumberish,
      target: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fillOrder(
      order: OrderMixin.OrderStruct,
      signature: BytesLike,
      fixedTokens: BigNumberish,
      variableTokens: BigNumberish,
      thresholdTokens: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fillOrderTo(
      order: OrderMixin.OrderStruct,
      signature: BytesLike,
      fixedTokens: BigNumberish,
      variableTokens: BigNumberish,
      thresholdTokens: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fillOrderToWithPermit(
      order: OrderMixin.OrderStruct,
      signature: BytesLike,
      fixedTokens: BigNumberish,
      variableTokens: BigNumberish,
      thresholdTokens: BigNumberish,
      permit: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    getAverageAccruedAPYBetweenTimestamps(
      asset: string,
      underlyingAsset: string,
      startTimestamp: BigNumberish,
      endTimestamp: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getInitialMarginReq(
      order: OrderMixin.OrderStruct,
      orderHash: BytesLike,
      participant: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getMakerAmount(
      orderMakerAmount: BigNumberish,
      orderTakerAmount: BigNumberish,
      swapTakerAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getMarginReq(
      order: OrderMixin.OrderStruct,
      orderHash: BytesLike,
      participant: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTakerAmount(
      orderMakerAmount: BigNumberish,
      orderTakerAmount: BigNumberish,
      swapMakerAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    gt(
      value: BigNumberish,
      target: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    hashOrder(
      order: OrderMixin.OrderStruct,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    increaseNonce(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    isOrderDefaulted(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    liquidate(
      order: OrderMixin.OrderStruct,
      defaulter: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    liquidatorMargin(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lt(
      value: BigNumberish,
      target: string,
      data: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    nonce(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    nonceEquals(
      makerAddress: string,
      makerNonce: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    oppositePartyMargin(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    oppositePartyMarginNoLiquidator(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    or(
      targets: string[],
      data: BytesLike[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    orderParticipantFixedTokens(
      arg0: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    orderParticipantMargin(
      arg0: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    orderParticipantVariableTokens(
      arg0: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    remaining(
      orderHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    remainingRaw(
      orderHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    setAssetAlpha(
      asset: string,
      alpha: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setAssetBeta(
      asset: string,
      beta: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setAssetLowerBoundMul(
      asset: string,
      lowerBoundMul: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setAssetSigma(
      asset: string,
      sigma: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setAssetUpperBoundMul(
      asset: string,
      upperBoundMul: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setLiquidatorMargin(
      _liquidatorMargin: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setOppositePartyMargin(
      _oppositePartyMargin: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setOppositePartyMarginNoLiquidator(
      _oppositePartyMarginNoLiquidator: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    settleOrder(
      order: OrderMixin.OrderStruct,
      settler: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    simulateCalls(
      targets: string[],
      data: BytesLike[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    singlePrice(
      oracle: string,
      inverseAndSpread: BigNumberish,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    timestampBelow(
      time: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
